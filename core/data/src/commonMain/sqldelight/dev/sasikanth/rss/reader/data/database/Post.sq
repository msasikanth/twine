import kotlin.Boolean;
import kotlin.time.Instant;

CREATE TABLE post(
  id TEXT NOT NULL,
  sourceId TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  imageUrl TEXT,
  postDate INTEGER AS Instant NOT NULL,
  createdAt INTEGER AS Instant NOT NULL,
  updatedAt INTEGER AS Instant NOT NULL,
  syncedAt INTEGER AS Instant NOT NULL,
  link TEXT NOT NULL,
  commentsLink TEXT DEFAULT NULL,
  bookmarked INTEGER AS Boolean NOT NULL DEFAULT 0,
  read INTEGER AS Boolean NOT NULL DEFAULT 0,
  isHidden INTEGER AS Boolean NOT NULL DEFAULT 0,
  PRIMARY KEY (id, sourceId),
  FOREIGN KEY(sourceId) REFERENCES feed(id) ON DELETE CASCADE
);

CREATE INDEX post_date_index ON post (postDate);
CREATE INDEX post_createdAt_index ON post (createdAt);
CREATE INDEX post_is_hidden_index ON post(isHidden);
CREATE INDEX post_date_read_hidden_index ON post(postDate, read, isHidden);

CREATE TRIGGER hide_post_if_blocked_word_is_present_AFTER_INSERT
AFTER INSERT ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%'
) IS NOT NULL
BEGIN
  UPDATE post SET isHidden = 1 WHERE id = new.id;
END;

CREATE TRIGGER hide_post_if_blocked_word_is_present_BEFORE_UPDATE
BEFORE UPDATE OF title, description ON post -- Removed rawContent
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%') AND
    new.isHidden == 0
) IS NOT NULL
BEGIN
  UPDATE post SET isHidden = 1 WHERE id = new.id;
END;

CREATE TRIGGER unhide_post_if_no_blocked_words_present_and_post_is_hidden_BEFORE_UPDATE
UPDATE OF title, description ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%')
) IS NULL AND old.isHidden == 1
BEGIN
  UPDATE post SET isHidden = 0 WHERE id = new.id;
END;

upsert:
INSERT INTO post(id, sourceId, title, description, imageUrl, postDate, createdAt, updatedAt, syncedAt, link, commentsLink)
VALUES (:id,  :sourceId, :title, :description, :imageUrl, :postDate,  :createdAt, :updatedAt, :syncedAt, :link, :commnetsLink)
ON CONFLICT(id, sourceId) DO
UPDATE SET
    title = excluded.title,
    description = excluded.description,
    imageUrl = excluded.imageUrl,
    postDate = CASE WHEN :isDateParsedCorrectly == 1 AND postDate < excluded.postDate THEN excluded.postDate ELSE postDate END;

allPostsCount:
SELECT COUNT(post.id) FROM post
WHERE
  ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
  post.isHidden == 0 AND
  (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
  post.postDate > :postsAfter AND
  post.syncedAt < :lastSyncedAt;

allPosts:
WITH featuredPosts AS (
  SELECT
    post.id,
    sourceId,
    post.title,
    post.description,
    post.imageUrl,
    post.postDate,
    post.link,
    post.commentsLink,
    post.bookmarked,
    post.read,
    feed.name AS feedName,
    feed.icon AS feedIcon,
    feed.homepageLink AS feedHomepageLink,
    feed.alwaysFetchSourceArticle,
    1 AS isFeatured
  FROM post
  INNER JOIN feed ON post.sourceId == feed.id
  WHERE
    ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
    post.isHidden == 0 AND
    (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
    post.imageUrl IS NOT NULL AND
    post.postDate > :postsAfter AND
    post.syncedAt < :lastSyncedAt
  ORDER BY post.postDate DESC
  LIMIT :numberOfFeaturedPosts
)

SELECT * FROM featuredPosts

UNION ALL

SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.postDate,
  post.link,
  post.commentsLink,
  post.bookmarked,
  post.read,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle,
  0 AS isFeatured
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
  post.isHidden == 0 AND
  (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
  post.id NOT IN (SELECT id FROM featuredPosts) AND
  post.postDate > :postsAfter AND
  post.syncedAt < :lastSyncedAt
ORDER BY isFeatured DESC, postDate DESC
LIMIT :limit OFFSET :offset;

updateBookmarkStatus:
UPDATE post SET bookmarked = :bookmarked WHERE id = :id;

updateReadStatus:
UPDATE post SET read = :read WHERE id = :id;

deleteReadPosts:
DELETE FROM post
WHERE post.read == 1 AND post.postDate < :before
RETURNING post.sourceId;

markPostsAsRead:
UPDATE post
SET read = CASE WHEN read != 1 THEN 1 ELSE read END
WHERE (sourceId = :sourceId OR :sourceId IS NULL) AND postDate > :after;

post:
SELECT * FROM post
WHERE post.id = :id;

unreadPostsCountInSource:
SELECT COUNT(*) FROM post
WHERE
  ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
  post.isHidden == 0 AND
  read != 1 AND
  postDate > :after;

unreadSinceLastSync:
SELECT COUNT(post.id),
(
  SELECT GROUP_CONCAT(homepageLink, ',')
  FROM (
    SELECT DISTINCT feed.homepageLink
    FROM post
    INNER JOIN feed ON post.sourceId == feed.id
    WHERE
      ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
      post.isHidden == 0 AND
      read != 1 AND
      post.postDate > :postsAfter AND
      post.syncedAt > :lastSyncedAt
    ORDER BY post.syncedAt
    LIMIT 3
  )
) AS feedHomepageLinks,
(
  SELECT GROUP_CONCAT(icon, ',')
  FROM (
    SELECT DISTINCT feed.icon
    FROM post
    INNER JOIN feed ON post.sourceId == feed.id
    WHERE
      ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
      post.isHidden == 0 AND
      read != 1 AND
      post.postDate > :postsAfter AND
      post.syncedAt > :lastSyncedAt
    ORDER BY post.syncedAt
    LIMIT 3
  )
) AS feedIcons
FROM post
WHERE
  ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
  post.isHidden == 0 AND
  read != 1 AND
  post.postDate > :postsAfter AND
  post.syncedAt > :lastSyncedAt;

countPostsForFeed:
SELECT COUNT(*) FROM post
WHERE sourceId = :feedId;

widgetUnreadPostsCount:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  post.isHidden == 0 AND
  post.read == 0
ORDER BY postDate DESC;

widgetUnreadPosts:
SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.postDate,
  post.link,
  post.commentsLink,
  post.bookmarked,
  post.read,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  post.isHidden == 0 AND
  post.read == 0
ORDER BY postDate DESC
LIMIT :numberOfPosts OFFSET :offset;
