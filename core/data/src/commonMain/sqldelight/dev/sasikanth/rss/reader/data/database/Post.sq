import dev.sasikanth.rss.reader.core.model.local.PostFlag;
import kotlin.collections.Set;
import kotlin.time.Instant;

CREATE TABLE post(
  id TEXT NOT NULL,
  sourceId TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  imageUrl TEXT,
  postDate INTEGER AS Instant NOT NULL,
  createdAt INTEGER AS Instant NOT NULL,
  updatedAt INTEGER AS Instant NOT NULL,
  syncedAt INTEGER AS Instant NOT NULL,
  link TEXT NOT NULL,
  commentsLink TEXT DEFAULT NULL,
  flags INTEGER AS Set<PostFlag> NOT NULL DEFAULT 0,
  PRIMARY KEY (id, sourceId),
  FOREIGN KEY(sourceId) REFERENCES feed(id)
);

CREATE TRIGGER IF NOT EXISTS delete_post_content_AFTER_DELETE
AFTER DELETE ON post
BEGIN
  DELETE FROM postContent WHERE id = old.id;
END;

CREATE INDEX post_date_index ON post (postDate);
CREATE INDEX post_createdAt_index ON post (createdAt);
CREATE INDEX post_sourceId_index ON post (sourceId);

CREATE TRIGGER hide_post_if_blocked_word_is_present_AFTER_INSERT
AFTER INSERT ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%'
) IS NOT NULL
BEGIN
  UPDATE post SET flags = flags | 4 WHERE id = new.id;
END;

CREATE TRIGGER hide_post_if_blocked_word_is_present_BEFORE_UPDATE
BEFORE UPDATE OF title, description ON post -- Removed rawContent
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%') AND
    (new.flags & 4) == 0
) IS NOT NULL
BEGIN
  UPDATE post SET flags = flags | 4 WHERE id = new.id;
END;

CREATE TRIGGER unhide_post_if_no_blocked_words_present_and_post_is_hidden_BEFORE_UPDATE
UPDATE OF title, description ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%')
) IS NULL AND (old.flags & 4) != 0
BEGIN
  UPDATE post SET flags = flags & ~4 WHERE id = new.id;
END;

upsert:
INSERT INTO post(id, sourceId, title, description, imageUrl, postDate, createdAt, updatedAt, syncedAt, link, commentsLink)
VALUES (:id,  :sourceId, :title, :description, :imageUrl, :postDate,  :createdAt, :updatedAt, :syncedAt, :link, :commentsLink)
ON CONFLICT(id, sourceId) DO
UPDATE SET
    title = excluded.title,
    description = excluded.description,
    imageUrl = excluded.imageUrl,
    postDate = CASE WHEN :isDateParsedCorrectly == 1 AND postDate < excluded.postDate THEN excluded.postDate ELSE postDate END;

allPostsCount:
SELECT COUNT(post.id) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
  (post.flags & 4) == 0 AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly) AND
  post.postDate > :postsAfter AND
  post.syncedAt < :lastSyncedAt;

allPosts:
WITH baseQuery AS (
  SELECT
    post.id AS id,
    post.sourceId AS sourceId,
    post.title AS title,
    post.description AS description,
    post.imageUrl AS imageUrl,
    post.postDate AS postDate,
    post.createdAt AS createdAt,
    post.link AS link,
    post.commentsLink AS commentsLink,
    post.flags AS flags,
    feed.name AS feedName,
    feed.icon AS feedIcon,
    feed.homepageLink AS feedHomepageLink,
    feed.alwaysFetchSourceArticle AS alwaysFetchSourceArticle
  FROM post
  INNER JOIN feed ON post.sourceId == feed.id
  WHERE
    ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
    (post.flags & 4) == 0 AND
    feed.isDeleted = 0 AND
    (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly) AND
    post.postDate > :postsAfter AND
    post.syncedAt < :lastSyncedAt
),
featuredPosts AS (
  SELECT
    *,
    1 AS isFeatured
  FROM baseQuery
  WHERE imageUrl IS NOT NULL
  ORDER BY
    CASE WHEN :orderBy = 'Latest' THEN postDate END DESC,
    CASE WHEN :orderBy = 'Oldest' THEN postDate END ASC,
    CASE WHEN :orderBy = 'AddedLatest' THEN createdAt END DESC,
    CASE WHEN :orderBy = 'AddedOldest' THEN createdAt END ASC
  LIMIT :numberOfFeaturedPosts
)
SELECT * FROM (
  SELECT * FROM featuredPosts

  UNION ALL

  SELECT * FROM (
    SELECT
      *,
      0 AS isFeatured
    FROM baseQuery
    WHERE id NOT IN (SELECT id FROM featuredPosts)
    ORDER BY
      CASE WHEN :orderBy = 'Latest' THEN postDate END DESC,
      CASE WHEN :orderBy = 'Oldest' THEN postDate END ASC,
      CASE WHEN :orderBy = 'AddedLatest' THEN createdAt END DESC,
      CASE WHEN :orderBy = 'AddedOldest' THEN createdAt END ASC
    LIMIT :limit + :offset
  )
)
ORDER BY
  isFeatured DESC,
  CASE WHEN :orderBy = 'Latest' THEN postDate END DESC,
  CASE WHEN :orderBy = 'Oldest' THEN postDate END ASC,
  CASE WHEN :orderBy = 'AddedLatest' THEN createdAt END DESC,
  CASE WHEN :orderBy = 'AddedOldest' THEN createdAt END ASC
LIMIT :limit OFFSET :offset;

updateBookmarkStatus:
UPDATE post SET flags = CASE WHEN :bookmarked = 1 THEN flags | 1 ELSE flags & ~1 END WHERE id = :id;

updateReadStatus:
UPDATE post SET flags = CASE WHEN :read = 1 THEN flags | 2 ELSE flags & ~2 END WHERE id = :id;

deleteReadPosts:
DELETE FROM post
WHERE (post.flags & 2) != 0 AND post.postDate < :before
RETURNING post.sourceId;

markPostsAsRead:
UPDATE post
SET flags = flags | 2
WHERE (sourceId = :sourceId OR :sourceId IS NULL)
  AND postDate > :after
  AND (flags & 2) == 0;

post:
SELECT * FROM post
WHERE post.id = :id;

unreadPostsCountInSource:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0 AND
  post.postDate > :after AND
  (:isSourceIdsEmpty OR post.sourceId IN :sourceIds);

unreadSinceLastSync:
WITH unreadPosts AS (
  SELECT
    feed.homepageLink,
    feed.icon,
    post.syncedAt
  FROM post
  INNER JOIN feed ON post.sourceId == feed.id
  WHERE
    ((:isSourceIdsEmpty) OR post.sourceId IN :sourceIds) AND
    (post.flags & 4) == 0 AND
    feed.isDeleted = 0 AND
    (post.flags & 2) == 0 AND
    post.postDate > :postsAfter AND
    post.syncedAt > :lastSyncedAt
)
SELECT COUNT(*),
(
  SELECT GROUP_CONCAT(homepageLink, ',')
  FROM (
    SELECT DISTINCT homepageLink
    FROM unreadPosts
    ORDER BY syncedAt
    LIMIT 3
  )
) AS feedHomepageLinks,
(
  SELECT GROUP_CONCAT(icon, ',')
  FROM (
    SELECT DISTINCT icon
    FROM unreadPosts
    ORDER BY syncedAt
    LIMIT 3
  )
) AS feedIcons
FROM unreadPosts;

countPostsForFeed:
SELECT COUNT(*) FROM post
WHERE sourceId = :feedId;

widgetUnreadPostsCount:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0
ORDER BY postDate DESC;

widgetUnreadPosts:
SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.postDate,
  post.createdAt,
  post.link,
  post.commentsLink,
  post.flags,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0
ORDER BY postDate DESC
LIMIT :numberOfPosts OFFSET :offset;

deletePostsForFeed:
DELETE FROM post
WHERE sourceId = :feedId AND (flags & 1) == 0;
