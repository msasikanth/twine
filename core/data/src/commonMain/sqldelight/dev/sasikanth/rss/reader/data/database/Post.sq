import dev.sasikanth.rss.reader.core.model.local.PostFlag;
import kotlin.collections.Set;
import kotlin.time.Instant;

CREATE TABLE post(
  id TEXT NOT NULL,
  sourceId TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  imageUrl TEXT,
  postDate INTEGER AS Instant NOT NULL,
  createdAt INTEGER AS Instant NOT NULL,
  updatedAt INTEGER AS Instant NOT NULL,
  syncedAt INTEGER AS Instant NOT NULL,
  link TEXT NOT NULL,
  commentsLink TEXT DEFAULT NULL,
  flags INTEGER AS Set<PostFlag> NOT NULL DEFAULT 0,
  remoteId TEXT,
  audioUrl TEXT,
  PRIMARY KEY (id, sourceId),
  FOREIGN KEY(sourceId) REFERENCES feed(id)
);

CREATE TRIGGER IF NOT EXISTS delete_post_content_AFTER_DELETE
AFTER DELETE ON post
BEGIN
  DELETE FROM postContent WHERE id = old.id;
END;

CREATE INDEX post_date_index ON post (postDate);
CREATE INDEX post_createdAt_index ON post (createdAt);
CREATE INDEX post_sourceId_index ON post (sourceId);

CREATE INDEX post_all_posts_latest_index ON post((imageUrl IS NOT NULL AND postDate > 0) DESC, postDate DESC, createdAt DESC);
CREATE INDEX post_all_posts_oldest_index ON post((imageUrl IS NOT NULL AND postDate > 0) DESC, postDate ASC, createdAt ASC);
CREATE INDEX post_all_posts_added_latest_index ON post((imageUrl IS NOT NULL AND postDate > 0) DESC, createdAt DESC, postDate DESC);
CREATE INDEX post_all_posts_added_oldest_index ON post((imageUrl IS NOT NULL AND postDate > 0) DESC, createdAt ASC, postDate ASC);

CREATE INDEX post_remoteId_index ON post(remoteId) WHERE remoteId IS NOT NULL;
CREATE INDEX post_link_index ON post(link);
CREATE INDEX post_sync_index ON post(updatedAt, syncedAt) WHERE remoteId IS NOT NULL;
CREATE INDEX post_bookmarked_index ON post(id) WHERE (flags & 1) != 0;
CREATE INDEX post_read_index ON post(id) WHERE (flags & 2) != 0;

CREATE TRIGGER hide_post_if_blocked_word_is_present_AFTER_INSERT
AFTER INSERT ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%'
) IS NOT NULL
BEGIN
  UPDATE post SET flags = flags | 4 WHERE id = new.id;
END;

CREATE TRIGGER hide_post_if_blocked_word_is_present_BEFORE_UPDATE
BEFORE UPDATE OF title, description ON post -- Removed rawContent
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%') AND
    (new.flags & 4) == 0
) IS NOT NULL
BEGIN
  UPDATE post SET flags = flags | 4 WHERE id = new.id;
END;

CREATE TRIGGER unhide_post_if_no_blocked_words_present_and_post_is_hidden_BEFORE_UPDATE
UPDATE OF title, description ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%')
) IS NULL AND (old.flags & 4) != 0
BEGIN
  UPDATE post SET flags = flags & ~4 WHERE id = new.id;
END;

upsert:
INSERT INTO post(id, sourceId, title, description, imageUrl, audioUrl, postDate, createdAt, updatedAt, syncedAt, link, commentsLink)
VALUES (:id,  :sourceId, :title, :description, :imageUrl, :audioUrl, :postDate,  :createdAt, :updatedAt, :syncedAt, :link, :commentsLink)
ON CONFLICT(id, sourceId) DO
UPDATE SET
    title = excluded.title,
    description = excluded.description,
    imageUrl = excluded.imageUrl,
    audioUrl = excluded.audioUrl,
    postDate = CASE WHEN :isDateParsedCorrectly == 1 AND postDate < excluded.postDate THEN excluded.postDate ELSE postDate END;

allPostsCount:
SELECT COUNT(post.id) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
  (post.flags & 4) == 0 AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly) AND
  post.postDate > :postsAfter AND
  post.createdAt < :lastSyncedAt;

allPostsLatest:
SELECT
  post.id AS id,
  post.sourceId AS sourceId,
  post.title AS title,
  post.description AS description,
  post.imageUrl AS imageUrl,
  post.audioUrl AS audioUrl,
  post.postDate AS postDate,
  post.createdAt AS createdAt,
  post.link AS link,
  post.commentsLink AS commentsLink,
  post.flags AS flags,
  post.remoteId AS remoteId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle AS alwaysFetchSourceArticle,
  feed.showFeedFavIcon AS showFeedFavIcon,
  pc.feedContentReadingTime AS feedContentReadingTime,
  pc.articleContentReadingTime AS articleContentReadingTime,
  (post.imageUrl IS NOT NULL AND post.postDate > :featuredPostsAfter) AS isFeatured
FROM post INDEXED BY post_all_posts_latest_index
INNER JOIN feed ON post.sourceId = feed.id
LEFT JOIN postContent pc ON post.id = pc.id
WHERE
  (post.imageUrl IS NOT NULL AND post.postDate > 0) >= 0 AND
  post.postDate > :postsAfter AND
  post.createdAt < :lastSyncedAt AND
  (post.flags & 4) = 0 AND
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly)
ORDER BY
  (imageUrl IS NOT NULL AND postDate > 0) DESC,
  post.postDate DESC,
  post.createdAt DESC
LIMIT :limit OFFSET :offset;

allPostsOldest:
SELECT
  post.id AS id,
  post.sourceId AS sourceId,
  post.title AS title,
  post.description AS description,
  post.imageUrl AS imageUrl,
  post.audioUrl AS audioUrl,
  post.postDate AS postDate,
  post.createdAt AS createdAt,
  post.link AS link,
  post.commentsLink AS commentsLink,
  post.flags AS flags,
  post.remoteId AS remoteId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle AS alwaysFetchSourceArticle,
  feed.showFeedFavIcon AS showFeedFavIcon,
  pc.feedContentReadingTime AS feedContentReadingTime,
  pc.articleContentReadingTime AS articleContentReadingTime,
  (post.imageUrl IS NOT NULL AND post.postDate > :featuredPostsAfter) AS isFeatured
FROM post INDEXED BY post_all_posts_oldest_index
INNER JOIN feed ON post.sourceId = feed.id
LEFT JOIN postContent pc ON post.id = pc.id
WHERE
  (post.imageUrl IS NOT NULL AND post.postDate > 0) >= 0 AND
  post.postDate > :postsAfter AND
  post.createdAt < :lastSyncedAt AND
  (post.flags & 4) = 0 AND
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly)
ORDER BY
  (imageUrl IS NOT NULL AND postDate > 0) DESC,
  post.postDate ASC,
  post.createdAt ASC
LIMIT :limit OFFSET :offset;

allPostsAddedLatest:
SELECT
  post.id AS id,
  post.sourceId AS sourceId,
  post.title AS title,
  post.description AS description,
  post.imageUrl AS imageUrl,
  post.audioUrl AS audioUrl,
  post.postDate AS postDate,
  post.createdAt AS createdAt,
  post.link AS link,
  post.commentsLink AS commentsLink,
  post.flags AS flags,
  post.remoteId AS remoteId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle AS alwaysFetchSourceArticle,
  feed.showFeedFavIcon AS showFeedFavIcon,
  pc.feedContentReadingTime AS feedContentReadingTime,
  pc.articleContentReadingTime AS articleContentReadingTime,
  (post.imageUrl IS NOT NULL AND post.postDate > :featuredPostsAfter) AS isFeatured
FROM post INDEXED BY post_all_posts_added_latest_index
INNER JOIN feed ON post.sourceId = feed.id
LEFT JOIN postContent pc ON post.id = pc.id
WHERE
  (post.imageUrl IS NOT NULL AND post.postDate > 0) >= 0 AND
  post.postDate > :postsAfter AND
  post.createdAt < :lastSyncedAt AND
  (post.flags & 4) = 0 AND
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly)
ORDER BY
  (imageUrl IS NOT NULL AND postDate > 0) DESC,
  post.createdAt DESC,
  post.postDate DESC
LIMIT :limit OFFSET :offset;

allPostsAddedOldest:
SELECT
  post.id AS id,
  post.sourceId AS sourceId,
  post.title AS title,
  post.description AS description,
  post.imageUrl AS imageUrl,
  post.audioUrl AS audioUrl,
  post.postDate AS postDate,
  post.createdAt AS createdAt,
  post.link AS link,
  post.commentsLink AS commentsLink,
  post.flags AS flags,
  post.remoteId AS remoteId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle AS alwaysFetchSourceArticle,
  feed.showFeedFavIcon AS showFeedFavIcon,
  pc.feedContentReadingTime AS feedContentReadingTime,
  pc.articleContentReadingTime AS articleContentReadingTime,
  (post.imageUrl IS NOT NULL AND post.postDate > :featuredPostsAfter) AS isFeatured
FROM post INDEXED BY post_all_posts_added_oldest_index
INNER JOIN feed ON post.sourceId = feed.id
LEFT JOIN postContent pc ON post.id = pc.id
WHERE
  (post.imageUrl IS NOT NULL AND post.postDate > 0) >= 0 AND
  post.postDate > :postsAfter AND
  post.createdAt < :lastSyncedAt AND
  (post.flags & 4) = 0 AND
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly)
ORDER BY
  (imageUrl IS NOT NULL AND postDate > 0) DESC,
  post.createdAt ASC,
  post.postDate ASC
LIMIT :limit OFFSET :offset;

updateBookmarkStatus:
UPDATE post SET flags = CASE WHEN :bookmarked = 1 THEN flags | 1 ELSE flags & ~1 END, updatedAt = :updatedAt WHERE id = :id;

updateReadStatus:
UPDATE post SET flags = CASE WHEN :read = 1 THEN flags | 2 ELSE flags & ~2 END, updatedAt = :updatedAt WHERE id = :id;

deleteReadPosts:
DELETE FROM post
WHERE (post.flags & 2) != 0 AND post.postDate < :before
RETURNING post.sourceId;

deleteReadPostsForFeed:
DELETE FROM post
WHERE sourceId = :feedId AND (post.flags & 2) != 0 AND post.postDate < :before;

markPostsAsRead:
UPDATE post
SET flags = flags | 2, updatedAt = :updatedAt
WHERE (sourceId = :sourceId OR :sourceId IS NULL)
  AND postDate > :after
  AND (flags & 2) == 0;

post:
SELECT * FROM post
WHERE post.id = :id;

postByRemoteId:
SELECT * FROM post
WHERE remoteId = :remoteId;

postByLink:
SELECT * FROM post
WHERE link = :link;

updatePostRemoteId:
UPDATE post SET remoteId = :remoteId, updatedAt = :updatedAt, syncedAt = :updatedAt WHERE id = :id;

updatePostSyncedAt:
UPDATE post SET syncedAt = :syncedAt WHERE id = :id;

postsWithRemoteId:
SELECT * FROM post WHERE remoteId IS NOT NULL;

postsWithRemoteIdPaged:
SELECT * FROM post
WHERE remoteId IS NOT NULL
ORDER BY id
LIMIT :limit OFFSET :offset;

postsWithLocalChanges:
SELECT * FROM post WHERE updatedAt > syncedAt AND remoteId IS NOT NULL;

postsWithLocalChangesPaged:
SELECT * FROM post
WHERE updatedAt > syncedAt AND remoteId IS NOT NULL
ORDER BY id
LIMIT :limit OFFSET :offset;

postsWithLocalChangesForFeed:
SELECT * FROM post WHERE updatedAt > syncedAt AND remoteId IS NOT NULL AND sourceId = :feedId;

postsWithLocalChangesForFeedPaged:
SELECT * FROM post
WHERE updatedAt > syncedAt AND remoteId IS NOT NULL AND sourceId = :feedId
ORDER BY id
LIMIT :limit OFFSET :offset;

unreadPostsCountInSource:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0 AND
  post.postDate > :after AND
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds);

countPostsForFeed:
SELECT COUNT(*) FROM post
WHERE sourceId = :feedId;

widgetUnreadPostsCount:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0
ORDER BY postDate DESC;

widgetUnreadPosts:
SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.audioUrl,
  post.postDate,
  post.createdAt,
  post.link,
  post.commentsLink,
  post.flags,
  post.remoteId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle,
  feed.showFeedFavIcon,
  pc.feedContentReadingTime AS feedContentReadingTime,
  pc.articleContentReadingTime AS articleContentReadingTime
FROM post
INNER JOIN feed ON post.sourceId == feed.id
LEFT JOIN postContent pc ON post.id == pc.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0
ORDER BY postDate DESC
LIMIT :numberOfPosts OFFSET :offset;

deletePostsForFeed:
DELETE FROM post
WHERE sourceId = :feedId AND (flags & 1) == 0;

allReadPostsBlocking:
SELECT id, updatedAt FROM post WHERE (flags & 2) != 0;

deleteAll:
DELETE FROM post;

upsertSyncPost:
INSERT INTO post(id, sourceId, title, description, imageUrl, audioUrl, postDate, createdAt, updatedAt, syncedAt, link, commentsLink, flags, remoteId)
VALUES (:id, :sourceId, :title, :description, :imageUrl, :audioUrl, :postDate, :createdAt, :updatedAt, :syncedAt, :link, :commentsLink, :flags, :remoteId)
ON CONFLICT(id, sourceId) DO
UPDATE SET
    title = excluded.title,
    description = excluded.description,
    imageUrl = excluded.imageUrl,
    audioUrl = excluded.audioUrl,
    postDate = excluded.postDate,
    updatedAt = excluded.updatedAt,
    syncedAt = excluded.syncedAt,
    flags = excluded.flags,
    remoteId = excluded.remoteId
WHERE excluded.updatedAt > post.updatedAt;

unreadSinceLastSync:
WITH unreadPosts AS (
  SELECT
    f.id AS feedId,
    f.homepageLink,
    f.icon,
    f.showFeedFavIcon,
    p.createdAt
  FROM post p
  INNER JOIN feed f ON p.sourceId = f.id
  WHERE ((:isSourceIdsEmpty AND f.hideFromAllFeeds = 0) OR p.sourceId IN :sourceIds)
    AND (p.flags & 4) = 0
    AND f.isDeleted = 0
    AND (p.flags & 2) = 0
    AND p.postDate > :postsAfter
    AND p.createdAt > :lastSyncedAt
)
SELECT
  COUNT(*) AS count,
  (
    SELECT GROUP_CONCAT(homepageLink, '::')
    FROM (
      SELECT homepageLink, MAX(createdAt) AS maxSyncedAt
      FROM unreadPosts
      GROUP BY feedId
      ORDER BY maxSyncedAt DESC
      LIMIT 3
    )
  ) AS feedHomepageLinks,
  (
    SELECT GROUP_CONCAT(icon, '::')
    FROM (
      SELECT icon, MAX(createdAt) AS maxSyncedAt
      FROM unreadPosts
      GROUP BY feedId
      ORDER BY maxSyncedAt DESC
      LIMIT 3
    )
  ) AS feedIcons,
  (
    SELECT GROUP_CONCAT(CASE WHEN showFeedFavIcon IS NULL THEN 'null' WHEN showFeedFavIcon = 1 THEN 'true' ELSE 'false' END, '::')
    FROM (
      SELECT showFeedFavIcon, MAX(createdAt) AS maxSyncedAt
      FROM unreadPosts
      GROUP BY feedId
      ORDER BY maxSyncedAt DESC
      LIMIT 3
    )
  ) AS feedShowFavIconSettings
FROM unreadPosts;

totalReadPostsCount:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 2) != 0 AND
  (post.flags & 4) == 0 AND
  feed.isDeleted = 0;

readPostsByFeed:
SELECT
  feed.id AS feedId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  COUNT(post.id) AS readCount
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 2) != 0 AND
  (post.flags & 4) == 0 AND
  feed.isDeleted = 0
GROUP BY feed.id, feed.name, feed.icon
ORDER BY readCount DESC;

readPostsOverTime:
SELECT
  DATE(postDate / 1000, 'unixepoch') AS date,
  COUNT(*) AS count
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 2) != 0 AND
  (post.flags & 4) == 0 AND
  feed.isDeleted = 0 AND
  postDate >= :startDate
GROUP BY date
ORDER BY date DESC;
