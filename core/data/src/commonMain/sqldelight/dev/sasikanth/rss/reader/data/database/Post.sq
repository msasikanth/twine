import dev.sasikanth.rss.reader.core.model.local.PostFlag;
import kotlin.collections.Set;
import kotlin.time.Instant;

CREATE TABLE post(
  id TEXT NOT NULL,
  sourceId TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  imageUrl TEXT,
  postDate INTEGER AS Instant NOT NULL,
  createdAt INTEGER AS Instant NOT NULL,
  updatedAt INTEGER AS Instant NOT NULL,
  syncedAt INTEGER AS Instant NOT NULL,
  link TEXT NOT NULL,
  commentsLink TEXT DEFAULT NULL,
  flags INTEGER AS Set<PostFlag> NOT NULL DEFAULT 0,
  remoteId TEXT,
  PRIMARY KEY (id, sourceId),
  FOREIGN KEY(sourceId) REFERENCES feed(id)
);

CREATE TRIGGER IF NOT EXISTS delete_post_content_AFTER_DELETE
AFTER DELETE ON post
BEGIN
  DELETE FROM postContent WHERE id = old.id;
END;

CREATE INDEX post_date_index ON post (postDate);
CREATE INDEX post_createdAt_index ON post (createdAt);
CREATE INDEX post_sourceId_index ON post (sourceId);

CREATE TRIGGER hide_post_if_blocked_word_is_present_AFTER_INSERT
AFTER INSERT ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%'
) IS NOT NULL
BEGIN
  UPDATE post SET flags = flags | 4 WHERE id = new.id;
END;

CREATE TRIGGER hide_post_if_blocked_word_is_present_BEFORE_UPDATE
BEFORE UPDATE OF title, description ON post -- Removed rawContent
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%') AND
    (new.flags & 4) == 0
) IS NOT NULL
BEGIN
  UPDATE post SET flags = flags | 4 WHERE id = new.id;
END;

CREATE TRIGGER unhide_post_if_no_blocked_words_present_and_post_is_hidden_BEFORE_UPDATE
UPDATE OF title, description ON post
FOR EACH ROW
WHEN (
  SELECT 1
  FROM blockedWord
  WHERE
    (new.title LIKE '%' || blockedWord.content || '%' OR
    new.description LIKE '%' || blockedWord.content || '%')
) IS NULL AND (old.flags & 4) != 0
BEGIN
  UPDATE post SET flags = flags & ~4 WHERE id = new.id;
END;

upsert:
INSERT INTO post(id, sourceId, title, description, imageUrl, postDate, createdAt, updatedAt, syncedAt, link, commentsLink)
VALUES (:id,  :sourceId, :title, :description, :imageUrl, :postDate,  :createdAt, :updatedAt, :syncedAt, :link, :commentsLink)
ON CONFLICT(id, sourceId) DO
UPDATE SET
    title = excluded.title,
    description = excluded.description,
    imageUrl = excluded.imageUrl,
    postDate = CASE WHEN :isDateParsedCorrectly == 1 AND postDate < excluded.postDate THEN excluded.postDate ELSE postDate END;

allPostsCount:
SELECT COUNT(post.id) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
  (post.flags & 4) == 0 AND
  feed.isDeleted = 0 AND
  (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly) AND
  post.postDate > :postsAfter AND
  post.createdAt < :lastSyncedAt;

allPosts:
WITH baseQuery AS (
  SELECT
    post.id AS id,
    post.sourceId AS sourceId,
    post.title AS title,
    post.description AS description,
    post.imageUrl AS imageUrl,
    post.postDate AS postDate,
    post.createdAt AS createdAt,
    post.link AS link,
    post.commentsLink AS commentsLink,
    post.flags AS flags,
    post.remoteId AS remoteId,
    feed.name AS feedName,
    feed.icon AS feedIcon,
    feed.homepageLink AS feedHomepageLink,
    feed.alwaysFetchSourceArticle AS alwaysFetchSourceArticle,
    feed.showFeedFavIcon AS showFeedFavIcon
  FROM post
  INNER JOIN feed ON post.sourceId == feed.id
  WHERE
    ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds) AND
    (post.flags & 4) == 0 AND
    feed.isDeleted = 0 AND
    (:unreadOnly IS NULL OR ((post.flags & 2) != 0) != :unreadOnly) AND
    post.postDate > :postsAfter AND
    post.createdAt < :lastSyncedAt
),
featuredPosts AS (
  SELECT
    *,
    1 AS isFeatured
  FROM baseQuery
  WHERE imageUrl IS NOT NULL
  ORDER BY
    CASE WHEN :orderBy = 'Latest' THEN postDate END DESC,
    CASE WHEN :orderBy = 'Oldest' THEN postDate END ASC,
    CASE WHEN :orderBy = 'AddedLatest' THEN createdAt END DESC,
    CASE WHEN :orderBy = 'AddedOldest' THEN createdAt END ASC
  LIMIT :numberOfFeaturedPosts
)
SELECT * FROM (
  SELECT * FROM featuredPosts

  UNION ALL

  SELECT * FROM (
    SELECT
      *,
      0 AS isFeatured
    FROM baseQuery
    WHERE id NOT IN (SELECT id FROM featuredPosts)
    ORDER BY
      CASE WHEN :orderBy = 'Latest' THEN postDate END DESC,
      CASE WHEN :orderBy = 'Oldest' THEN postDate END ASC,
      CASE WHEN :orderBy = 'AddedLatest' THEN createdAt END DESC,
      CASE WHEN :orderBy = 'AddedOldest' THEN createdAt END ASC
    LIMIT :limit + :offset
  )
)
ORDER BY
  isFeatured DESC,
  CASE WHEN :orderBy = 'Latest' THEN postDate END DESC,
  CASE WHEN :orderBy = 'Oldest' THEN postDate END ASC,
  CASE WHEN :orderBy = 'AddedLatest' THEN createdAt END DESC,
  CASE WHEN :orderBy = 'AddedOldest' THEN createdAt END ASC
LIMIT :limit OFFSET :offset;

updateBookmarkStatus:
UPDATE post SET flags = CASE WHEN :bookmarked = 1 THEN flags | 1 ELSE flags & ~1 END, updatedAt = :updatedAt WHERE id = :id;

updateReadStatus:
UPDATE post SET flags = CASE WHEN :read = 1 THEN flags | 2 ELSE flags & ~2 END, updatedAt = :updatedAt WHERE id = :id;

deleteReadPosts:
DELETE FROM post
WHERE (post.flags & 2) != 0 AND post.postDate < :before
RETURNING post.sourceId;

deleteReadPostsForFeed:
DELETE FROM post
WHERE sourceId = :feedId AND (post.flags & 2) != 0 AND post.postDate < :before;

markPostsAsRead:
UPDATE post
SET flags = flags | 2, updatedAt = :updatedAt
WHERE (sourceId = :sourceId OR :sourceId IS NULL)
  AND postDate > :after
  AND (flags & 2) == 0;

post:
SELECT * FROM post
WHERE post.id = :id;

postByRemoteId:
SELECT * FROM post
WHERE remoteId = :remoteId;

postByLink:
SELECT * FROM post
WHERE link = :link;

updatePostRemoteId:
UPDATE post SET remoteId = :remoteId, updatedAt = :updatedAt, syncedAt = :updatedAt WHERE id = :id;

updatePostSyncedAt:
UPDATE post SET syncedAt = :syncedAt WHERE id = :id;

postsWithRemoteId:
SELECT * FROM post WHERE remoteId IS NOT NULL;

postsWithLocalChanges:
SELECT * FROM post WHERE updatedAt > syncedAt AND remoteId IS NOT NULL;

unreadPostsCountInSource:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0 AND
  post.postDate > :after AND
  ((:isSourceIdsEmpty AND feed.hideFromAllFeeds = 0) OR post.sourceId IN :sourceIds);

countPostsForFeed:
SELECT COUNT(*) FROM post
WHERE sourceId = :feedId;

widgetUnreadPostsCount:
SELECT COUNT(*) FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0
ORDER BY postDate DESC;

widgetUnreadPosts:
SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.postDate,
  post.createdAt,
  post.link,
  post.commentsLink,
  post.flags,
  post.remoteId,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle,
  feed.showFeedFavIcon
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (post.flags & 4) == 0 AND
  (post.flags & 2) == 0 AND
  feed.isDeleted = 0
ORDER BY postDate DESC
LIMIT :numberOfPosts OFFSET :offset;

deletePostsForFeed:
DELETE FROM post
WHERE sourceId = :feedId AND (flags & 1) == 0;

allReadPostsBlocking:
SELECT id, updatedAt FROM post WHERE (flags & 2) != 0;

deleteAll:
DELETE FROM post;

upsertSyncPost:
INSERT INTO post(id, sourceId, title, description, imageUrl, postDate, createdAt, updatedAt, syncedAt, link, commentsLink, flags, remoteId)
VALUES (:id, :sourceId, :title, :description, :imageUrl, :postDate, :createdAt, :updatedAt, :syncedAt, :link, :commentsLink, :flags, :remoteId)
ON CONFLICT(id, sourceId) DO
UPDATE SET
    title = excluded.title,
    description = excluded.description,
    imageUrl = excluded.imageUrl,
    postDate = excluded.postDate,
    updatedAt = excluded.updatedAt,
    syncedAt = excluded.syncedAt,
    flags = excluded.flags,
    remoteId = excluded.remoteId
WHERE excluded.updatedAt > post.updatedAt;

unreadSinceLastSync:
WITH unreadPosts AS (
  SELECT
    f.id AS feedId,
    f.homepageLink,
    f.icon,
    f.showFeedFavIcon,
    p.createdAt
  FROM post p
  INNER JOIN feed f ON p.sourceId = f.id
  WHERE ((:isSourceIdsEmpty AND f.hideFromAllFeeds = 0) OR p.sourceId IN :sourceIds)
    AND (p.flags & 4) = 0
    AND f.isDeleted = 0
    AND (p.flags & 2) = 0
    AND p.postDate > :postsAfter
    AND p.createdAt > :lastSyncedAt
)
SELECT
  COUNT(*) AS count,
  (
    SELECT GROUP_CONCAT(homepageLink, '::')
    FROM (
      SELECT homepageLink, MAX(createdAt) AS maxSyncedAt
      FROM unreadPosts
      GROUP BY feedId
      ORDER BY maxSyncedAt DESC
      LIMIT 3
    )
  ) AS feedHomepageLinks,
  (
    SELECT GROUP_CONCAT(icon, '::')
    FROM (
      SELECT icon, MAX(createdAt) AS maxSyncedAt
      FROM unreadPosts
      GROUP BY feedId
      ORDER BY maxSyncedAt DESC
      LIMIT 3
    )
  ) AS feedIcons,
  (
    SELECT GROUP_CONCAT(CASE WHEN showFeedFavIcon IS NULL THEN 'null' WHEN showFeedFavIcon = 1 THEN 'true' ELSE 'false' END, '::')
    FROM (
      SELECT showFeedFavIcon, MAX(createdAt) AS maxSyncedAt
      FROM unreadPosts
      GROUP BY feedId
      ORDER BY maxSyncedAt DESC
      LIMIT 3
    )
  ) AS feedShowFavIconSettings
FROM unreadPosts;
