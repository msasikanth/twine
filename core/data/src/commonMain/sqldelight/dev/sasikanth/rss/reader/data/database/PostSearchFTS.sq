CREATE VIRTUAL TABLE IF NOT EXISTS post_search USING FTS5(
  id TEXT NOT NULL PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  link TEXT NOT NULL,
  tokenize="trigram"
);

CREATE TRIGGER IF NOT EXISTS
post_search_fts_BEFORE_DELETE
BEFORE DELETE ON post
BEGIN DELETE FROM post_search WHERE id = old.id;
END;

CREATE TRIGGER IF NOT EXISTS
post_search_fts_AFTER_UPDATE
AFTER UPDATE ON post
BEGIN UPDATE OR IGNORE post_search SET title = new.title, description = new.description WHERE id = new.id;
END;

CREATE TRIGGER IF NOT EXISTS
post_search_fts_AFTER_INSERT
AFTER INSERT ON post
BEGIN INSERT OR IGNORE INTO post_search(id, title, description, link) VALUES (new.id, new.title, new.description, new.link);
END;

countSearchResults:
SELECT COUNT(*) FROM post_search ps
INNER JOIN post p ON p.id = ps.id
INNER JOIN feed f ON p.sourceId = f.id
WHERE ps.post_search MATCH :searchQuery AND f.isDeleted = 0 AND (p.flags & 4) == 0;

search:
SELECT
  post.id,
  sourceId,
  post_search.title,
  post_search.description,
  post.imageUrl,
  post.postDate,
  post.createdAt,
  post.link,
  post.commentsLink,
  post.flags,
  feed.name AS feedName,
  feed.icon AS feedIcon,
  feed.homepageLink AS feedHomepageLink,
  feed.alwaysFetchSourceArticle,
  feed.showFeedFavIcon
FROM post_search
INNER JOIN post ON post.id == post_search.id
INNER JOIN feed ON post.sourceId == feed.id
WHERE post_search MATCH :searchQuery AND feed.isDeleted = 0 AND (post.flags & 4) == 0
ORDER BY
  CASE WHEN :sortOrder = 'oldest' THEN post.postDate END ASC,
  CASE WHEN :sortOrder = 'newest' THEN post.postDate END DESC
LIMIT :limit OFFSET :offset;
