import kotlin.Boolean;
import kotlinx.datetime.Instant;

CREATE TABLE post(
  id TEXT NOT NULL PRIMARY KEY,
  sourceId TEXT NOT NULL,
  title TEXT NOT NULL,
  description TEXT NOT NULL,
  rawContent TEXT,
  imageUrl TEXT,
  date INTEGER AS Instant NOT NULL,
  link TEXT NOT NULL,
  commentsLink TEXT DEFAULT NULL,
  bookmarked INTEGER AS Boolean NOT NULL DEFAULT 0,
  read INTEGER AS Boolean NOT NULL DEFAULT 0,
  FOREIGN KEY(sourceId) REFERENCES feed(id) ON DELETE CASCADE
);

CREATE INDEX post_source_id_index ON post(sourceId);

upsert:
INSERT INTO post(id, sourceId, title, description, rawContent, imageUrl, date, link, commentsLink)
VALUES (:id,  :sourceId, :title, :description,  :rawContent, :imageUrl, :date, :link, :commnetsLink)
ON CONFLICT(id) DO
UPDATE SET title = excluded.title, description = excluded.description, rawContent = excluded.rawContent, imageUrl = excluded.imageUrl, date = excluded.date;

count:
SELECT COUNT(*) FROM post
WHERE
  (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
  (:sourceId IS NULL OR post.sourceId = :sourceId) AND
  -- Skip featured posts --
  post.id NOT IN (
    SELECT post.id FROM post
    WHERE
    (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
    (:sourceId IS NULL OR post.sourceId = :sourceId) AND
    post.imageUrl IS NOT NULL AND
    post.date > :postsAfter
    ORDER BY post.date DESC LIMIT :featuredPostsLimit
  ) AND
  -- Skip featured posts --
  post.date > :postsAfter
ORDER BY post.date DESC;

featuredPosts:
SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.date,
  post.link,
  post.commentsLink,
  post.bookmarked,
  post.read,
  feed.name AS feedName,
  feed.icon AS feedIcon
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
  (:sourceId IS NULL OR post.sourceId = :sourceId) AND
  post.imageUrl IS NOT NULL AND
  post.date > :postsAfter
ORDER BY post.date DESC LIMIT :limit;

posts:
SELECT
  post.id,
  sourceId,
  post.title,
  post.description,
  post.imageUrl,
  post.date,
  post.link,
  post.commentsLink,
  post.bookmarked,
  post.read,
  feed.name AS feedName,
  feed.icon AS feedIcon
FROM post
INNER JOIN feed ON post.sourceId == feed.id
WHERE
  (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
  (:sourceId IS NULL OR post.sourceId = :sourceId) AND
  -- Skip featured posts --
  post.id NOT IN (
    SELECT post.id FROM post
    WHERE
    (:unreadOnly IS NULL OR post.read != :unreadOnly) AND
    (:sourceId IS NULL OR post.sourceId = :sourceId) AND
    post.imageUrl IS NOT NULL AND
    post.date > :postsAfter
    ORDER BY post.date DESC LIMIT :featuredPostsLimit
  ) AND
  -- Skip featured posts --
  post.date > :postsAfter
ORDER BY post.date DESC
LIMIT :limit OFFSET :offset;

updateBookmarkStatus:
UPDATE post SET bookmarked = :bookmarked WHERE id = :id;

updateReadStatus:
UPDATE post SET read = :read WHERE id = :id;

deleteReadPosts:
DELETE FROM post
WHERE post.read == 1 AND post.date < :before
RETURNING post.sourceId;

markPostsInFeedAsRead:
UPDATE post
SET read = CASE WHEN read != 1 THEN 1 ELSE read END
WHERE sourceId = :sourceId AND date > :after;

post:
SELECT * FROM post
WHERE post.id = :id;

hasPost:
SELECT EXISTS(SELECT 1 FROM post WHERE id = :id);
